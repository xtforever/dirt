




@(input)@ psfig



The Dirt User Interface Builder

Richard Hesketh
Computing Laboratory
University of Kent at Canterbury




@(bibliographystyle)@ alphathesis
abstract
The Dirt<1>
user interface builder provides an interactive editor for the
rapid-prototyping and iterative development of user interfaces using the
Xt Toolkit under the X Window System<2>.  User interfaces are created interactively by the direct manipulation 
of user interface objects (also called Widgets) such as push buttons,
menus and scroll bars.  Each object contains attributes (or resources) that
describe its look and feel; these attributes are also modified interactively.
Whilst building a user interface using Dirt the designer can use
objects are soon as he creates them.  This encourages exploration of the
available objects.  Dirt generates all the source code required for
the designed user interface and separates the user interface definition from the
application code.  Collections of objects can be created as Templates,
allowing generic dialog boxes etc. to be developed and copied into
interfaces.  This can be used to promote a consistent design style and
allow design reuse.  This report describes how to build user interfaces using
Dirt and how to link the application code into the resultant interface.
A separate report describes the implementation of Dirt and how to add
new objects to the system.  
abstract

@(newpage)@ 
@(tableofcontents)@ 
@(listoffigures)@ 
@(newpage)@ 

Introduction
The development of graphical user interfaces for applications on a graphical
workstation can be time-consuming and tedious.  To speed-up the development
of graphical user interfaces under the X Window System @CITE(cite{X,XBible})@  the Xt
Toolkit was developed @CITE(cite{XtBible})@ .  The Xt Toolkit provides the user
interface developer (who may not be a programmer) with a set of user
interface objects (also called Widgets) and a set of routines to create
and manipulate them (called the Intrinsics).  These objects provide
facilities such as push-buttons, scrollable windows, and editable text areas.
However the interface designer is still required to program in a traditional
programming language, C.

The Dirt User Interface Builder separates the development of a
graphical application into two interconnected areas; the user interface and
the application's functionality.  The application's functionality is still
developed in a traditional fashion in a programming language but the user
interface is created interactively though the direct manipulation of user
interface objects @CITE(cite{direct-manipulation})@ .  Dirt allows
non-programmers to design the layout and a lot of the operation (commonly
termed the look and feel) of the user interface.

Figure @REF(ref{fig:example})@  shows a typical dialog box in an user interface.  
It is made up of seven distinct interface objects, shown in the exploded view of
Figure @REF(ref{fig:example-hierarchy})@ .  Each object is an instance of a
particular
class.  The class defines the overall functions of the object and an
instance is a customized copy of the class.  Each object instance has a set of
attributes or resources which define its look and feel. 
Dirt allows these resources to be modified interactively so that
object instances can be produced quickly and later edited.

Each object has a parent object.  This produces a hierarchy
of objects with each parent controlling the layout and dimensions of its
children.  Figure @REF(ref{fig:example-hierarchy})@  also shows the object
hierarchy for the
example dialog of Figure @REF(ref{fig:example})@ .  Different classes of parents
control the size and positioning of objects placed inside them.  For example,
a ``tree'' class object may layout its children in the form of an n-ary
tree, while a ``row-column'' class may layout its children in a row and column
configuration.  A ``shell'' class is a special class that is the root of the
object hierarchy and is the window that is controlled by the window
manager @CITE(cite{XUsersGuideOReilly})@  of the workstation's display.

The link between the user interface objects and the application's
functionality is made via three toolkit facilities:itemize
+
Translation Table Actions --- call application procedures when certain X
events happen.
+
Callback Routines --- Objects call application procedures under certain
circumstances.
+
Interrogation of Objects by Application --- Application can control display
of interface objects and implement user interface modes.

The Xt Toolkit uses an event-based model where the application is informed
when certain external events happen.  Therefore the application reacts to the
user pressing buttons and typing at the keyboard.  Translation tables and
Callback lists form the basis of this communication between the interface and
the application.  User interface objects can also be examined from within the
application through the use of an identifier variable (automatically created
by Dirt) and the Xt Intrinsic routines.  The application can therefore
``Get'' or ``Set'' an object's resource values.

Dirt creates all the necessary C code to implement the designed user
interface and provides the necessary hooks to bind the interface to the
application.  The definition of the interface is saved in a resources
file (also called an application defaults file) which is read by the
creation routines at run-time.  For minor modifications to the interface,
such as changing object sizes, positions, colours etc. the application can
simply be re-executed to test these new features. Major modifications, such as
the addition of new dialog boxes may require recompilation of the application
to include the new Dirt generated C code.

Dirt includes a set of callback routines that implement useful
functions (listed in Appendix @REF(ref{appendix:callbacks})@ ).  These functions
are executable from within Dirt and the
final application, allowing some prototyping of the application's
functionality from within Dirt.

The Widget Creation Library @CITE(cite{Wcl})@  is used to re-create the user
interface at runtime from its definition in a resource file. This
resource file is created by Dirt. The user interface is 
therefore defined separately and only
``bound'' to the application at runtime. Keeping the user interface
separate to the application's functionality allows major modifications to
be made to the user interface without the need to modify the application's
functionality. The application can therefore be thought of as a
collection of standalone and inter-operational functions that are woven
together by the user interface. This therefore has a great impact on how
the application should be written. The application is therefore reactive to
the user's operations via actions and callbacks in the user interface.

There are parts of the user interface that cannot be designed before
runtime. For example, the display of a file-system browser cannot be
created directly in Dirt as the information that is to displayed is
dependent upon the external, ever changing, workstation environment. This
information is gathered by the application's functionality which then
converts it into a visual form. What Dirt can provide is support to
generate prototypical displays. These displays contain the basic user
interface objects with ``typical'' resource settings. This prototype part of
the user interface is then used by the application to create runtime
instances of the objects. The application ``fills in'' those parts of the
prototype that it has computed at runtime. These prototypical objects are
known as deferred objects and are described in
Section @REF(ref{sec:deferred-creation})@ .

	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/example.eps,width=4in
	  --------------- Caption for figure or table: -------------
Example dialog box

<<==========================================================>>


	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/exploded.eps,width=3in
@(hspace)@ .75in
figure=figures/hier.eps,height=2in

	  --------------- Caption for figure or table: -------------
The objects in the example dialog box and their hierarchy

<<==========================================================>>


Using the Dirt Interface Builder
To run Dirt type:
verbatim
      
verbatim
at the command prompt (for a complete list of command line options see the
on-line manual page or Appendix @REF(ref{appendix:command-line-args})@ ).
After a short
while the main Dirt window is displayed.  This window is shown in
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/main-window.ps,width=4.5in
	  --------------- Caption for figure or table: -------------
Dirt main window

<<==========================================================>>

Figure @REF(ref{fig:main-window})@  and contains the main menu,
widget instance list and popup dialog box buttons.

You can now create, edit or extend an application's interface or produce a
reverse engineered interface for an existing application.  Object hierarchies
can be grouped as ``Templates'' that can be copied into
interfaces.  Templates allow general dialog boxes to be created and reused
across different interfaces, reducing design time and allowing a
consistent in-house style to be created.

Creating an Application Window

Every user interface created by Dirt must have at least one application
top level (or shell) window (whose parent is the display's root
window).  This special user interface widget has its own popup dialog box
which can be popped up by clicking on the ``Application Details'' button
with the first mouse button.  Thefigure
figure=figures/app-dialog-box.ps,width=4.5in
	  --------------- Caption for figure or table: -------------
Application Details popup dialog

<<==========================================================>>

popped up dialog is shown in Figure @REF(ref{fig:app-dialog-box})@ .  Each
application requires two names to identify it; an instance name and a class
name.  The class name identifies a collection of related applications and the
instance name identifies a particular application.

The class and instance names should follow the Xt Toolkit resource naming
conventions as described in Section 1.6.1 ``Widget Naming Conventions''
in the Xt Intrinsics reference manual @CITE(cite{XtIntrinsics})@ .
Some valid application names are: dirt, resourceEditor
and xterm.  Some valid class names are: Dirt,
ResourceEditor and XTerm.

The application resources (shown in the lower part of the window in
Figure @REF(ref{fig:app-dialog-box})@ ) are for an
Application Shell Class widget.
For details of what each resource does see Chapter 4 ``Shell Widgets'' in the
Xt Toolkit manual or use the on-line Help System (see
Section @REF(ref{sec:help})@ ).
See Section @REF(ref{sec:editing-resources})@  for exact details of how to modify
resources of a particular resource type.

The two push buttons labelled Create and Delete are used to
create or delete an application's interface.
The four value entries
below the class name box are used to specify the position and size (in screen
pixels) of the application shell widget.  They can be used to change the
application's size and position directly (rather than resizing or moving the
window using a window manager).

To create a new application shell the Create button should be pressed
after both the instance and class names have been set.  When the Create
button is pressed a prompt
window appears in the top left corner of the display you are building the
application on (by default this is the same display as Dirt but can be
set to a different display to allow building of large user interfaces, see
Appendix @REF(ref{appendix:command-line-args})@  for details).  The cursor changes to a
right-angle shape.  The first mouse button is pressed and a window is created
whose size and position has been specified using the four value entries below
the class name box.  Otherwise, by pressing and holding down the second mouse
button a
rectangle can be dragged out to the required size of the application window.
When the second button is released an application shell is created of the
desired size and position.

Next to each dimension or position value entry field is a ``lock'' icon.
If a lock is set (i.e. closed) then the value associated with it will be
output as part of the generated user interface.  If the lock is not set
(open), the value is ignored and is computed at runtime by the object.
The default case is to have all the locks unset. Here, the object will
choose a size that is just big enough to hold all its contents. The locks
should therefore be used to force objects to have a particular size
and/or position. It should be noted however that parent objects may override
these defaults (Section @REF(ref{sec:managed-parents})@ ).

The list of application resources are updated to reflect the newly created
application shell.  The values of these resources can be changed and the effect
on the application shell can be seen immediately.  If the application shell
is manipulated by the window manager (e.g. using a title bar for resizing)
the associated resource values are updated immediately.

Creating and using User Interface Objects
Once the main window of an interface has been created the rest of
the interface can be built using combinations of pre-designed user interface
objects or (widgets).  Whether an object is a scrollbar, push button or
pull-down menu it must be placed in or connected to a parent object
(see Section @REF(ref{sec:managed-parents})@  for the
normal use of parent objects).  Thus a Dirt built user interface is a
hierarchical collection of user interface objects whose individual appearance
and functionality (commonly termed the look and feel) have been
tailored by the designer from a given set of default values.

The ``Create New Widget Instance'' popup dialog (see
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/new-dialog-box.ps,width=6.5in
	  --------------- Caption for figure or table: -------------
Create New Widget Instance popup dialog

<<==========================================================>>

Figure @REF(ref{fig:new-dialog-box})@ ) allows us to create specific instances of
objects taken from a collection of pre-designed object classes.  These
objects can be placed in the interface being developed or in a template
(see Section @REF(ref{sec:templates})@ ).

When the ``Create New Widget Instance'' dialog is popped up (by pressing the
``Create New Widget Instance'' button in the main Dirt window), the
designer is presented with a scrollable list of available object (or Widget)
classes.  By clicking the first mouse button on an entry in this list we can
see the resources which define the look and feel of the widget class.
The resource list is similar to the application shell resource list and is
used in the same way (see Section @REF(ref{sec:editing-resources})@ ).

Choosing the Most Suitable User Interface Object
The biggest problem associated with building user interfaces using generic
objects is knowing which objects to use.  The objects available in Dirt
fall into two broad categories; Simple and Composite objects.
A Simple object is, as the name implies, a very basic object with a
defined function; examples of simple objects are scrollbars and push buttons.
A Composite object is a more complex object and controls (or manages)
the type and geometry of any child objects placed in it; examples of composite
objects are layout, form or box objects.

Some objects are hybrids, they are composite objects
that contain instances of simple objects;
An example of a hybrid object is a Viewport.  A viewport may contain
horizontal and vertical scrollbars, a clipping window and a clipped child.
Only the clipped child is not created by the viewport class when a viewport
object is created.

User interfaces in Dirt are therefore built up as a hierarchy of simple
(or hybrid) objects inside composite object parents.  Dirt allows small
hierarchies to be created as templates (Section @REF(ref{sec:templates})@ ).
These templates can be used to quickly create an interface from existing
collections of objects.

Appendix @REF(ref{appendix:objects})@  gives brief details of all the object classes
currently supported by Dirt.  Each class is documented in a
separate manual or on-line manual page.

Dirt does not give advice on which objects are best to use, it simply
allows any object to be chosen and used accordingly. However, what
Dirt does allow is experimentation using objects.  All the
resources defined by a particular object class can be modified interactively
to explore their function.  The popup ``example'' dialogs contain typical
example uses of objects in a particular Widget Set (see
Section @REF(ref{sec:examples})@ ).

Dirt does give the designer context sensitive help concerning
the resources of a
particular object class.  This help is displayed whenever the designer
presses any of the resource label buttons in a resource list.
For full details of this help facility see Section @REF(ref{sec:help})@ .

Using Simple Objects
The choice of available objects in Dirt ranges from very basic objects
such as text labels or push buttons to more complex, hybrid objects such
as a scrollable list of items.  Each object class includes a set of resources
that control the look and feel of instances of the class.  When an instance
of the class is created it contains a copy of these resources initially set
to default values specified in the object class. These class default
values can be overriden before creation using the editable resource list
in the ``Create New Widget Instance'' dialog box.

Using Composite Objects

Composite objects are objects specifically designed to contain child
objects.  A composite object is normally used to control the layout and
visual structure of a user interface.  They act as place holders for the
actual interaction objects; the simple objects.

The dialog window shown in Figure @REF(ref{fig:new-dialog-box})@  is an example of
the most common use of composite parents.  The two push buttons near to the
top of the dialog are children of a ``Layout'' parent.  This parent acts as a
canvas upon which the buttons are placed.  Different composite parents have
different sets of rules for Geometry Management (see Chapter 11
``Geometry Management'' in @CITE(cite{ProgrammingXt})@  for a detailed look at
geometry management in the Xt Toolkit).  These rules are used by the parent
to decide where to place newly created children and how to resize them if
they make a request to change size or the parent changes size.

These layout and resize rules are (normally) only applied to children
that are currently in the parent's managed set.  A child can be
added or removed from a parent's managed set by toggling the Managed
button in the ``Create New Widget Instance'' and ``Edit Widget Instance''
dialogs.  By default the object will disappear (become unmapped) from
inside the
parent when it becomes unmanaged.  This can be changed by toggling the
mappedWhenManaged resource of the object.

Many standard forms of layout such as list or row and column formatting are
performed automatically by parents.  However more complex layout formatting
requires some thought on behalf of the interface designer.  The composite
parent may need more information before it can correctly apply its geometry
management rules.  This information is given by setting resource values in
both the parent and children.  Setting resources in the parent will control
global (i.e. all children of the parent) aspects of geometry management.
However, to make particular children appear in certain positions or resize in
a certain way requires resources in the children to be set.  These resources
are normally given to them by a subclass of the composite object class;
known as constraint class parents.  These constraint resources only
exist whilst the child is in the constraint parent.  If the child is moved to
a new parent (Section @REF(ref{sec:reparenting})@ ) these resources are removed from
the child (possibly replaced by new constraints).
Section @REF(ref{sec:editing-constraints})@  details how these resources are
edited.

Picking Object Classes From Real Examples

We can also examine different widget classes by picking widgets from popup
dialogs containing examples of their use.  These example dialogs are displayed
by pressing the first mouse button inside the ``Examples''
menu button to reveal
a list of available widget sets (a widget set being a collection of vendor
or task related widget classes).
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/xaw-examples.ps,width=6.5in
	  --------------- Caption for figure or table: -------------
Athena Widget Set Examples Dialog

<<==========================================================>>

Figure @REF(ref{fig:xaw-examples})@  shows the examples popup for the MIT Athena
Widget Set @CITE(cite{XawWidgets})@ .  Choosing one of these sets causes a dialog
to be popped up.  These dialogs contain example instances of widget classes
and how they may be used.  To select a particular widget class from an
example dialog we must ``pick it up'' using the pointer.  To do this the
cursor should be placed inside or on the boundary of the designated widget (the
four corners of the widget are highlighted indicating the current choice) and
double
click the first mouse button whilst holding down the Shift key.  The class
name of this widget is also shown in the ``Widget Class:'' text label,
highlighted in the list of ``Available Widget Classes'' and the resources for
this class are displayed in the ``Resources'' list.

To set both the new
instance's parent and widget class, a copy of the example widget can be
dragged into place in the interface. This is done by holding down the first
mouse button and the Shift key and moving the pointer
(which is tracked by a
rectangular dashed frame) into the interface.  Releasing the mouse button
causes the class name, ``Available Widget Classes'' and ``Resources'' areas
to be updated.  The parent entry is set to the object the frame was dragged
and dropped over.

The new object's parent can also be chosen by typing the parent's name into
the ``Parent's Name:'' text entry area or Picking it from the interface.
To do this press the Pick button next to the ``Parent's Name:'' text entry
area (in Dirt the cursor is changed to a cross-hair target to indicate
an object in the interface should be chosen).  Pressing a mouse button in
a window that is not part of the developing interface causes the Picking operation to be ignored.

Creating Objects

After you have chosen the class of object you
wish to create and you have given it a name (and possibly a particular
parent) and you have set any resources, you can now press the Create
button.  When the Create button is pressed the cursor changes to a
right-angle shape.  By pressing the first mouse button a window is created
whose size and position is calculated by the object and its parent.
If the object does cannot calculate a default size, the size/position is
taken from the four value entries below
the parent box.  By pressing and holding down the second mouse button a
rectangle can be dragged out to the required size of the object.
When the button is released an object is created.

If the parent has not been chosen when the Create button is pressed it is
automatically inferred from the mouse pointer's position. If a
rectangle was dragged out to indicate the size and position of the 
object, then the parent chosen is the object which contains this 
rectangle.<3>

If the parent chosen is in the ``Template Building Area'' the object
is created as part of the currently opened template.  Objects in templates
are created and manipulated using the same functions as used for objects in
interfaces.  However, all template objects are children of the ``Template
Building Area'' and are listed in the ``Template Hierarchy'' rather than
the ``Widget Instances'' list.  See Section @REF(ref{sec:templates})@  for more
details on the use of templates.

If the Managed button was set to true (a tick),
newly created objects are placed in their parent's managed set (and therefore
under its geometry management).
This managed status can be changed using the Managed button in
the ``Edit Widget Instance'' dialog.
If the object class is a shell subclass the managed button has no effect as
shells are controlled by the window manager and not the logical parent.

The actual size and position of the created object is dependent upon
the class of the parent object.  Two general types of parent object exist:
description
+composite --- Parent objects that control the placement and/or
the size of child objects are know as composite objects.  When a child of a
composite object is created its size and position may be controlled by the
parent if the child is in the parent's managed set.  A child can be
removed or added to the parent's managed set using the Managed
toggle button next to the ``Border Width'' value entry.

Different composite objects use different techniques for the layout of
managed children, some may tile children from left to right, top to bottom
(as in the Athena Box Widget) and some may place the children in a list
(possibly sorted).
+constraint --- A constraint parent controls managed children in
just the same way a composite object would do except that it uses a set of
constraint resources to work out their placement and size.  Each child is
given a copy of these resources and by setting these resources (they are
displayed in reverse video in the ``Editable Resources'' view of the ``Edit
Widget Instance'' popup dialog; see Section @REF(ref{sec:editing-constraints})@ )
you can adjust the layout of the child.
description

Naming Objects
Each object must be named (Dirt will not allow you to create an object
without a name) using the same conventions as used for the instance
name of the main application window (Section @REF(ref{sec:creating-app})@ ).
This name should be unique in relation
to other objects, however Dirt will enforce uniqueness via a
numbered suffix if required.

This name is used to identify the object by both Dirt and the
application.  Dirt generates a variable handle to the object which can
be used by the application to manipulate the object.  The name of this
variable is created directly from the object's name; for example if an object
is named mainLayout the associated variable Dirt will generate
will be WI_main_layout. When the application is executed the user
interface is generated and the object ids are assigned to these 
variables.

Deferred Runtime Creation Of Objects
In Dirt all objects are displayed as soon as they are created.
Also by default, all objects defined in Dirt are also created at
application runtime in one action.  However, the designer can defer creation
of objects (thus deferring creation of all their children) so that they
are not created in one go at runtime (i.e. when a call to
XukcCreateUserInterface() is made).  To set this the Deferred
button in either the ``Create New Widget Instance'' or
``Edit Widget Instance'' should be set to true (a tick is displayed).

If an object is marked as deferred, it can be created later
in the application
via a call to WcCreateNamedChildren().  This facility is detailed in
Section @REF(ref{sec:deferred-creation})@ .
Deferring the runtime creation of objects provides:

*
Decreased application startup time by only creating objects on demand.
*
Allows multiple objects to be created using the same layout and definition
(multiple objects with the same object name) under program control.
*
Allows objects to be placed on different displays (or screens).

When XukcCreateUserInterface() is called, it creates all the un-deferred
objects, adds default callbacks and actions for all the actions and callbacks
registered in Dirt (these are overridden using calls to
WcRegisterActions() and WcRegisterCallbacks()) and then places
all the created objects' ids in their associated Widget variable.


Editing Objects

Any object can be edited after it has been created.  To edit an object it must
first be selected.  This selection can be made by searching the scrollable
``Widget Instances'' list and clicking on the required object's entry.  If
the object you wish to edit is in the currently loaded template the
``Template Hierarchy'' list should be searched.  The
selection can also be made by Picking an object in the user interface or
the ``Template Building Area''.

When the Pick button (in the main menu) is pressed the cursor
changes to a cross-hair target.
When a mouse button is pressed the object that lies
underneath the cursor position is selected. Only objects that are in the
``Widget Instances'' or ``Template Hierarchy'' list can be selected;
sub-objects that are contained within
an object must be edited using the methods described
in Section @REF(ref{sec:editing-subobjects})@ .

When a valid object has been selected the current values of its resources are
displayed in the ``Edit Widget Instance'' dialog. 
If the application shell object is chosen the
``Application Details'' dialog is popped up.

	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/editing.ps,width=6.5in
	  --------------- Caption for figure or table: -------------
Editing a User Interface Object

<<==========================================================>>

The selected object is also highlighted in the user interface with
nine squares or grips, as can be seen in Figure @REF(ref{fig:editing})@ .
These grips can be used to re-position and resize the object (provided the
parent object allows the re-positioning).  Press the first mouse button in
any of the grips and holding it down, drag the mouse to a position.  A
``frame'' will follow the mouse showing the new position/size of the object.
When the button is released the object is moved and resized (under the
control of the parent). 

Apart from resizing and re-positioning objects the following attributes of
an object can be edited:description
+Resources --- The look and feel of an object is defined by the
values of its resources.  A resource is essentially a typed item of data
which belongs to an object.  When the value of a resource is modified the
object is notified so that it may refuse the modification (e.g. to disallow
out of range or other illegal values) or adjust the values of other resources
and data internal to the object that rely on the resource.
Each resource is given a default value by the
object class it is defined in.  These values can be modified before an object
is created using the ``Create New Widget Instance'' dialog or after it has
been created using the ``Edit Widget Instance'' dialog.  Typical resource
types include colours, fonts, strings, boolean types and bitmaps.  A resource
is classified as a 4-tuple; (name, class, type, value).  Only the
resource value can be modified.
+Constraint Resources --- Constraint resources are defined by
constraint parents but are given to their children. The values of the
constraint resources are used by the parent for geometry management
(Section @REF(ref{sec:geometry-management})@ ) of the child. If a child is moved or
copied from one parent to another the constraint resources are not copied.
+Translation Tables --- A translation table is a special resource
that is used to define ``Event to Action'' bindings. It is a text resource
that allows the designer to specify actions (either in the application's
functionality or in the interface) that are to be called when a certain
sequence of events happen. For example, the following translation table
might be set on a push button object:verbatim
       <Btn1Down>,<Btn1Up>: pushed()
verbatim
Here the action pushed is executed when the first mouse button is
pressed and released (clicked) inside the push button object.  What the pushed action does is defined in either the button itself or in the
application's functionality part.

New actions can be accessed by registering their names with Dirt, see
Section @REF(ref{sec:register-actions})@  for details.  The functionality of a new
action is only seen, however, when the interface is linked into the other
parts of the application.

+Callback Lists ---
A callback list resource is a list of callback routines.  These routines are
called in left to right order when this callback resource is executed (normally
by the object in response to some external event).  The name of a callback
routine can only be used in a callback list after it has been registered via
the ``Application Callbacks'' dialog.

+Sub-Object Resources ---
Some composite objects contain child objects created internally by them.  These
parents have been termed hybrid objects.  The child or sub-objects
contain resources that you may wish to modify directly.  Dirt allows
designers to access and modify these resources using the same methods as
described for ordinary resources.
description
Editing of these attribute types are discussed in the following sections.

Editing Resources

Apart from creating objects the other main function of Dirt is to allow
the editing of these objects.  User interfaces are developed using an
iterative cycle of design and evaluation (a complete definition of the tasks
involved in interface design can be found in @CITE(cite{newUITools})@ ).  Dirt
allows the designer to ``tinker'' with and modify a design whilst 
creating it, thus allowing
this design/evaluation cycle to be extremely fast.  Dirt achieves
this by allowing the resources in objects to be interactively edited.  The
results of the editing are seen immediately in the interface.

Figure @REF(ref{fig:editing})@  shows a typical interface being developed using
Dirt.  The designer has selected the exampleZoom12 object and
the ``Edit Widget Instance'' dialog has been popped up displaying the objects'
editable resources in a scrollable window.

One resource is given on each line of the resource list.  The first part
of the line contains the
type and name of the resource, the second part contains the current value of
the resource in an easily modifiable form.

The type tells the designer what sort of values the resource can take, i.e. a
Boolean resource can be one of two values, TRUE or FALSE.  The name is
the unique identifier of the resource in this class of object.  If the type
and name of the resource is displayed in reverse video then the resource is a
constraint, see the following section for how these resources differ.

The current value of a resource is displayed in a form that allows easy
editing for that type of resource.  For example the value of a Boolean
resource is given as a toggling button of either a tick (for true) or a cross
(for false).  Clicking the first mouse button toggles its value.

When a resource is modified, the object in the interface is informed and
updates itself internally, this is normally reflected in some visible change
in the object on the screen.  Dirt also stores the value of this
modified resource and saves this as part of the interfaces' specification.
Therefore when the interface is saved and subsequently re-loaded for editing,
the interface is re-created with these new resource values.

The following is a complete list of the methods currently used by Dirt
to allow interactive editing of resources:

minipage[t]0.25in
figure=figures/tick.ps,width=0.25in
minipage
--- Toggle button for boolean values.



minipage[t]0.7in
figure=figures/value.ps,width=0.7in
minipage
--- An integer number
whose value can be edited from the keyboard when the pointer is in the box.
The two arrows allow increment and decrement of the value (with an
auto-repeat facility) when they are pressed by the first mouse button.



minipage[t]2in
figure=figures/oneOfMany.ps,width=2in
minipage
--- ``one of many''
radio buttons for enumerated types. Only one discrete value can be selected,
cancelling the previous value. A button is selected by clicking the first
mouse button inside it. The currently set value is indicated by the filled
circle.



minipage[t]1.5in
figure=figures/manyOfMany.ps,width=1.5in
minipage
--- ``many of many''
buttons for flag or option types.  Any combination of discrete values
can be set.  A filled square indicates that the flag is currently set,
clicking the first mouse button in the name will toggle the flag's current
setting.



minipage[t]0.6in
figure=figures/selection.ps,width=0.6in
minipage
--- Externally
selected value.  Used for setting values that can be specified using another
X program; such as xfontsel<4>
for selecting fonts, or xcoloredit<5>
for mixing colours.  Pressing the first mouse button pulls in the current
value from one
of these editors if they are currently being used.  This is done via the X11
selection mechanism, refer to the manual pages for xfontsel and
xcoloredit for details as to how to select values in these programs.
The value can also be entered or edited directly using the second mouse
button and the keyboard.



minipage[t]1in
figure=figures/longName.ps,width=1in
minipage
--- Edit a sub-object.
Pressing the first mouse button causes a separate resource list to be
popped up showing all the resources of this object
(Section @REF(ref{sec:editing-subobjects})@ ). Pressing the second mouse
button reveals a vertical bar which can be positioned within the name and
edited from the keyboard. Pressing the Return key completes the
editing and checks the new value. Pressing the Escape key cancels the
edit mode. Pressing the third mouse button changes the cursor to small
cross-hair target. Now, the name of another object can be chosen by clicking
the first mouse over the object. The current value is changed to this new
object's name and the edit mode is entered.



minipage[t]1.3in
figure=figures/string.ps,height=.28in
minipage
--- The resource's current value is represented as a character string.  When
the pointer is moved into the string the border is highlighted to show that
the user can edit the string.  The carat insertion character shows where the
next typed character will be placed.  This can be moved around using the
pointer and the first mouse button.  Moving outside of the border causes this
new value to be accepted.



minipage[t]1.2in
figure=figures/pressToEdit.ps,width=1.2in
minipage
--- Pressing this button causes a separate dialog to pop up containing an editor
suitable for the resource type.  Currently the only use of this is for the
translations editor (Section @REF(ref{sec:editing-translations})@ ).



minipage[t]1in
figure=figures/children.ps,width=1in
minipage
--- This is a button list of children in a composite or constraint parent.
Each button can be pressed to pop up a separate dialog containing the child's
resources (Section @REF(ref{sec:editing-subobjects})@ ).

Constraint Resources

As mentioned in Section @REF(ref{sec:editing-objects})@  constraint resources are
given to a child object by its constraint parent.  They are special resources
that the parent uses to layout and resize its children on a per-child basis.
As such they are highlighted in reverse video.  They are edited using the
methods described in the previous section.  How constraint resources are
used is dependent upon the parent object.

Callback Lists

A callback list resource is a list of application callback routines that are
executed, in turn, when the callback list is executed.  In Dirt
these lists are represented as a character string with commas separating
routine names (with optional string parameters).  An example callback list
is:verbatim
   outputMessage("Goodbye World!"), WcExitCB()
verbatim
which, when executed, calls the outputMessage routine passing
"Goodbye World!" as a parameter string.  After this routine has
completed the WcExitCB routine is executed with no parameters passed.

Translation Tables

Translation tables are one of the two methods by which the user interface is
linked to the underlying application (the other method being callback
routines, described in Section @REF(ref{sec:callbacks})@ ).
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/translations.ps,width=6.5in
	  --------------- Caption for figure or table: -------------
Translation Table Editor Dialog

<<==========================================================>>

Translation tables are edited in a separate dialog (shown in
Figure @REF(ref{fig:translations})@ ).  This dialog contains three main areas: two
scrollable lists of available events and callable actions and a main text
area containing the current translations for the object.  A smaller pane
below the text area may also appear; this contains any error messages
reported by the translation table parsing mechanism.

Each line of the translations table contains an event sequence followed by a
list of actions to call when the event sequence is matched (separated by a
single colon ``:'').  The full
syntax of translation tables can be found in Appendix B
of @CITE(cite{XtIntrinsics})@ .  When an entry in the scrollable Event List
is selected (by pressing the first mouse button) it is copied into the
text area at the current insertion position (denoted by the carat character).
The same selection can be made in the Action List which copies the
action name followed by open and closing brackets.  Parameters can be passed
to action routines as comma separated strings inside these brackets.

The action names and parameters provide a straightforward yet powerful means
of binding the user interface to the application yet allowing each part to be
separately developed.  New actions are added in Dirt by registering the
action name in the ``Translation Actions'' pop up dialog, as shown in
Figure @REF(ref{fig:action-dialog})@ .  When the name has been registered it will be
added to the Action List and can be used in any translation table
resource.
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/action-dialog.ps,width=3.5in
	  --------------- Caption for figure or table: -------------
Translation Actions popup dialog

<<==========================================================>>


When the designer has finished setting the translations for a particular
object they can be applied, to see how they work in the actual interface.
When the Apply button is pressed the translation table is parsed into
an internal format and is checked for any errors.  These are reported in the
``Warnings:'' message area which will popup just below the text area.

If we have a look at the translation table given in
Figure @REF(ref{fig:translations})@  we see that these are the translations of a
button object.  They specify that when the first mouse button is clicked
the notify action is called.  No highlighting of the button is given
and once the user presses the first mouse button he cannot cancel the
operation.  To improve the look and feel of this button we can use the highlight and unhighlight actions built into the object's class.
We can specify that if the user holds down the first mouse button and
moves out of the button's border and releases the mouse button the operation
can be cancelled.  The notify action is only called when the
mouse button is released inside the button's border.  Also, to inform the
user when he has entered a button we can highlight its edges.  A new
translation table for these features would be:
verbatim
       Button1<EnterNotify>: highlight()
      Button1<EnterNotify>: set() highlight()
       Button1<LeaveNotify>: unhighlight()
      Button1<LeaveNotify>: unset() unhighlight()
      <Btn1Down>: set()
      <Btn1Up>: notify() unset()
verbatim

Dirt includes a set of built-in actions (defined by the Widget
Creation Library @CITE(cite{Wcl})@ ) which perform functions that
may be useful to most user interfaces. These are listed in
Appendix @REF(ref{appendix:actions})@ ; full descriptions can be found in the
Wcl documentation.

Sub-Object Resources

Some resources contain the identifiers to other objects.  These objects may be
children of a parent object or may be sub-objects created by a hybrid object
to implement a certain user interface technique; for example, a Viewport
object may create a horizontal and vertical scrollbar to allow the user to
scroll the viewport's contents.

To allow the designer to adjust these sub-objects Dirt will display the
resources of a sub-object when the sub-object button is pressed in the
resource list.  This displays the resources of the sub-object in a similar
resource list and allows the user to modify its resources in the same way.

Copying Objects

In Dirt any interface object can be easily copied.  To make a copy of
an object the designer must firstly select it.  This selection can be made
by searching the scrollable
``Widget Instances'' list and clicking on the required object's entry.  If
the object you wish to edit is in the currently loaded template the
``Template Hierarchy'' list should be searched.  The
selection can also be made by Picking an object in the user interface or
the ``Template Building Area''.

Once the object to be copied has been selected the Copy button in the
main menu should be pressed.  A sub-menu of two choices is popped up;
Single or Descendants.  Choosing Single, copies only the
selected object. Descendants copies both the selected object and any
descendants.

When one of these menu items is chosen the cursor is changed to a cross-hair
target prompting the designer to pick a destination parent.  The designer 
positions the cross-hair cursor inside the destination parent object
(the copy is
initially placed at this position but may be moved automatically by the
parent) and clicks the first mouse button.

A copy is now made of the selected object (and possibly its descendants) and
placed as a child of the destination object.  The name of the newly copied
object is changed if it clashes with the name of another sibling object.
This function can be used to put a copy of a template object
into an interface.

When an object is copied all the resources that have been edited are also
copied, with the following exceptions; constraint resources and sub-object
resources. If any of these resources had been modified then they
will also need to be modified in the the resultant copy.

Reparenting/Moving Objects

To move an object (and its descendants) from one parent to another the
Move menu button can be used.  This function operates in the same way as
the ``Copy Descendants'' function detailed in the previous section but the
originally selected object is deleted.

Deleting Objects

To delete an object in Dirt the object should be first selected
(see Section @REF(ref{sec:copying})@ ) and then the Delete button in the main
menu is pressed.
A dialog box is displayed which prompts the designer to confirm
the deletion.  If the Yes button is pressed the selected object and any
descendants are deleted.  The ``Widget Instances List'' is also updated.

Commenting Objects and Adding Context Help

Dirt allows the designer to comment the interface whilst it is being
developed.  These comments are added to individual objects and can be used to
direct further design or to record problems and design decisions as they crop
up.  In addition to comments, each object can have context help added to it
to allow a help system to be created.  Comments and help text are added
using the ``Comments and Help'' popup dialog, this is popped up by pressing
the Comments button in both the ``Application Details'' and
``Edit Widget Instance'' dialogs.

The designer is free to enter any comments or help text.  The comments and
help text are saved in the Dirt specification file and the
application resource file.  The help text is saved in the resource file as a
special resource entry (.dirtContextHelp) and can either be used directly
by the application or through the use of a suitable object class that refers
to this resource entry.

The comments and help are added on a per-object basis.  Therefore they are
added to the object currently being edited.

Creating and Using Templates

	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/templates.ps,width=6.5in
	  --------------- Caption for figure or table: -------------
Templates dialog and Template Building Area

<<==========================================================>>

Dirt allows the interface designer to create hierarchies of objects
that are not part of any particular interface.  These hierarchies are called
Templates and allows the designer to create a set of commonly used
dialog boxes or other collections of object instances and re-use them in
different interfaces.  Templates are created in a separate ``Template Building
Area'' (see Figure @REF(ref{fig:templates})@ ) and objects can then be copied (or
moved) from this area into the interface being developed.

The ``Templates'' button in the Dirt main window, when pressed, pops up
the ``Templates'' and ``Template Building Area'' (See
Figure @REF(ref{fig:templates})@ ).  The templates dialog contains three areas whose
individual sizes can be arranged by moving their ``panes'' around using the
square grips to the right of the dividing line.  These areas contain:

*
The textual ``Notes'' describing the template currently displayed in the
building area.  The designer is free to use this as a general commenting area
separate to the commenting of objects from the edit dialog.
*
A list of the available templates.  These templates are found by searching
the current directory and the (colon separated) directories given on the
command line using the -templates option.  When first started
Dirt examines each .dirt_template
suffixed file in the search directories and
creates a list of their names.  Templates are automatically saved when a new
one is created or an existing one is selected from the list.  New templates
are saved in the first directory in the -templates option or in the
directory Dirt was started up from.
*
A scrollable, hierarchical list of objects in the current template.  Objects
in the template can be edited by selecting them from this list or by
Picking them.

Once selected, objects can be edited, deleted, copied or reparented.  All the
template objects are children of the ``Template Building Area''.  Objects can
be copied or moved in and out of the template and into the main interface.

The ``Template Building Area'' is popped up whenever the ``Templates'' dialog
is popped up.  It is popped up on the same display as the developing
interface.  To pop this window down the Hide button should be clicked.

To create a new template the name of the template should be typed in the
``New Template:'' text area.  Pressing the Create button clears the
``Template Building Area'' and creates a blank template file.

Getting Help

Dirt has a limited help facility that can give context help regarding
the use of particular resources.  This help includes the description of a
resource, what its type is and a description of the object class it is used
in.  To receive this help, any of the resource names in the various ``Resource
Lists'' can be pressed to reveal a popup ``Context Help'' dialog as shown in
Figure @REF(ref{fig:help-dialog})@ .
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/help-dialog.ps,height=4in
	  --------------- Caption for figure or table: -------------
Context Help Popup Dialog

<<==========================================================>>

This dialog contains three areas:

*
A description of the resource which includes what the resource does and how
it is normally used.  References to relevant manuals are also given.
*
A description of the resource's type.  This includes the legal values that a
resource of this type can be set to. 
*
A detailed description of the Object class that this resource is defined in.
This description may include what actions this class defines and what
callbacks are normally used.


Saving the User Interface

To save a user interface the File button in the main menu should be
pressed.  This reveals a sub-menu of choices, Save should be
chosen and the button released.  This brings up the
``Save Interface Specification'' dialog box
	<<=========== NB! Please insert figure here. NB! ===========>>

figure=figures/save-dialog.ps,width=3.5in
	  --------------- Caption for figure or table: -------------
Save Interface Specification dialog box

<<==========================================================>>

as shown in Figure @REF(ref{fig:save-dialog})@ .  The two prefixes are used to
create the filename of the specification and generated code files.
These prefixes can contain forward slashes ``/'' denoting sub-directories.
One of the five buttons should be pressed to initiate or cancel the save
operation.

The specification file contains all the information required by Dirt to
re-edit the interface.  Its filename is  ``prefix.dirt_spec''.

The generated code is saved in two C source code files and an
applications defaults file.  The C code files are:description
+prefix_create.c ---
programmer routines called to create the user interface and bind the interface
to the application.
+prefix_layout.h ---
Definitions of the variables that hold object identifiers, these allow direct
access to the user interface from the application.  The variable names are
created from the object names.
description
The application's defaults file is saved in a file whose filename is the same
as the interface's classname.  It contains the full definition of the
interface as created under Dirt and is read by the creation routines at
runtime.  Dirt currently uses the ``Wc --- Widget Creation Library''
developed by David Smyth (david@devvax.jpl.nasa.gov) from work originally
done by Martin Brunecky (marbru@auto-trol.COM).  This library allows the
creation of a user interface from a resources file, along with a set of
callback and action binding routines.  The full specification of ``Wc'' is
given in @CITE(cite{Wcl})@ . 

The runtime separation of interface from functionality allows the
newly designed or edited interface to be executed for testing without having
to re-compile the application.  Section @REF(ref{sec:minimal-app})@  gives a minimal
application that allows the testing of an interface, it can also be used as
the starting point for developing full applications.

Loading a Saved User Interface

To edit a previously created interface the File button in the main menu
should be pressed.  This reveals a sub-menu of choices, Load should be
chosen and the button released.  A small dialog is popped up containing a
file prefix text area and a Load and Cancel button.

Pressing the Load button will attempt to load a new interface.
Cancel will cancel the operation.  The file prefix area should contain
the prefix of the Dirt specification
file:  prefix.dirt_spec.

If an interface already exists in Dirt the
``Save Interface Specification'' dialog is popped up to allow the interface
to be saved in its current state.  If the save is cancelled the current
interface will be lost when a new one is loaded.

Advanced Functions
Reverse Engineering an User Interface
This section will described how Dirt can latch on to a running
application (that has been linked against the UKC Widget Library) and
create a copy of the applications user interface in Dirt.
This allows an application to be converted to the Dirt approach to user
interface design and thus allow any further changes in its user interface
to be achieved via Dirt ... TO BE CONTINUED

Graphical Layout Constraints
Dirt contains some extra facilities for enhancing the operation of
UKCLayout class Widgets.  These facilities are invoked from the
Layout menu button and its popup submenu.  

This section will describe the use of layout constraints on the
UKCLayout and in the future the UKCGlue (a latex like constraint parent)
widget classes ... TO BE CONTINUED

Linking the User Interface to the Application

The user interface created by Dirt is linked to the application using
three main techniques; translation table actions, callback routines and
direct access to interface objects.  To implement these links Dirt
provides a mechanism for the interface designer to register names of objects,
callback routines and action routines.  These names, once registered, can be
used from within Dirt to build translation tables, callback lists and
connect objects together.  The C code generated by Dirt also includes a
mechanism for the application's programmer to bind these names to real
procedures in the application.  This is described in the following sections.
The binding of names used in the designed interface to procedures in the
application is performed at runtime.  Object names are automatically bound to
variables in the application by the generated routines that create the user
interface (see Section @REF(ref{sec:convenience})@ ).

Once a name has been registered in Dirt either as an action or a
callback, it can then be used in translation tables or callback lists.  When a
registered action or callback list is to be executed by the interface in
Dirt a message is displayed giving details of what object called this
routine and what parameters (if any) were passed.  In the final application
these names must be bound to actual routines before the interface is
created, see Sections @REF(ref{sec:bind-actions})@  and @REF(ref{sec:bind-callbacks})@ .

Registering New Actions

Action names are registered in Dirt using the ``Translation Actions''
dialog (see Figure @REF(ref{fig:action-dialog})@ ).  This dialog is popped up by
pressing the ``Translation Actions''
button in the main window.  This dialog contains a text area to enter the new
action name, a scrollable list of names already registered and a
Register button. When the register button is pressed the name given in
the text area is added to the (alphabetically sorted) list.  The name can now
be used within translation table resources.

Creating and Binding Action Routines in the Application

An action routine in the application is a C procedure defined as taking four
parameters; the id of the calling object, the last event in the sequence
which caused this action to be called, a list of parameters (given as
character strings) and the number of parameters passed.  An example C
definition is:verbatim
    void an_action(w, event, params, num_params)
    Widget w;              /* object id. */
    XEvent *event;         /* last event in translations sequence */
    String *params;        /* array of parameter strings */
    Cardinal *num_params;  /* number of parameters passed */
    
        /* application code to implement the action's function */
    
verbatim
To register this action as anAction the WcRegisterAction()
function should be used in the application:verbatim
    WcRegisterAction(app_context, "anAction", an_action);
verbatim
This routine performs the same function as the toolkit routine
XtAppAddActions().
This registration should be performed after the toolkit has been initialized
and before the user interface has been created by the call to
XukcCreateUserInterface().


Registering Callback Routines

Registering callback routine names in Dirt is performed in an identical
way as for action names but uses the ``Application Callbacks'' popup dialog.

Creating and Binding Callback Routines in the Application

A callback routine in the application is a C procedure defined as taking
three parameters; the id of the calling object, a pointer to data 
bound by either the application or interface (client_data) and 
data passed by the object at execution time (call_data).  An 
example C definition is:verbatim
    void a_callback(w, client_data, call_data)
    Widget w;              /* object id. */
    XtPointer client_data; /* pointer to application data */
    XtPointer call_data;   /* data passed to object */
    
        /* application code to implement the callback's function */
    
verbatim
To register this routine as aCallback the WcRegisterCallback()
function should be used in the application:verbatim
    WcRegisterCallback(app_context, "aCallback", a_callback, NULL);
verbatim
This registration should be performed after the toolkit has been 
initialized and before the user interface has been created by the call 
to XukcCreateUserInterface().

Programmer Convenience Routines

Dirt generates a collection of C routines for creating the user
interface from the generated resource file.  Through the use of these
routines the interface developed using Dirt can be quickly created
and bound to the application's functionality.  
Section @REF(ref{sec:minimal-app})@  gives an example minimal program that 
creates the user interface using the following routines:verbatim
Display *
XukcToolkitInitialize(dpy_str, app_name, app_class, argc, argv,
                      options, num_options, app_defaults)
    String dpy_str, app_name, app_class;
    int *argc;
    char **argv;
    XrmOptionDescRec options[];
    Cardinal num_options;
    String *app_defaults;
verbatim
This routine initializes the internals of the Xt Toolkit and opens a 
display connection to an X Server, strips out command line options and 
sets up any fallback resources for this display.  A pointer to the 
opened display structure is returned.  This routine is normally used 
from within the XukcDirtGO() function.  The following parameters 
are defined:description
+String dpy_str --- A character string naming the display the
application wishes to connect to.  If this value is
(String)NULL then the command line and user's environment is searched
for the display name.
+String app_name --- The (instance) name of the application, which
should have a lower-case first letter.
+String app_class --- The class name of the application, which
should have an upper-case first letter.
+int *argc --- A pointer to an integer containing the number of
arguments in argv.
+char **argv --- An array of character strings representing the
command line arguments passed to the application.
+XrmOptionDescRec options[] --- An array of command line options.
These options are searched for in argv, any matching arguments are
removed.  Values associated with matched options are placed in the resource
database associated with this display connection.  They can be retrieved using
the XtGetApplicationResources() function.
+Cardinal num_options --- The number of options passed.
+String *app_defaults --- An array of character strings which
contain resource database entries in the form of "*Background: blue".
These are set as the application fallback resources. They are only used
when an application resource file cannot be found.
description

@(rule)@ 4in1mm

verbatim
void
XukcDirtRegisterApplicationDefaults(screen, defs, n_defs)
    Screen *screen;
    String *defs;
    Cardinal n_defs;
verbatim
This routine merges valid resource entry strings into the resource database
associated with the screen. It can be used to load default values for
resources that can be overridden by an application resources file or by the
user from the command line (or user resources file). It takes the following
parameters:
description
+Screen *screen --- A pointer to a screen structure for an open
X connection.
+String *defs --- An array of character strings which contain
entries for a resource database.
+Cardinal n_defs --- The number of character strings.
description

@(rule)@ 4in1mm

verbatim
Widget
XukcDirtGO(dpy_str, argc, argv, options, num_options, app_defaults)
    String dpy_str;
    int *argc;
    char **argv;
    XrmOptionDescRec options;
    Cardinal num_options;
    String *app_defaults;
verbatim
This routine initializes the toolkit, opens a connection to the display,
creates the application's first shell window and strips any
options from the given command line.  It returns the id of the created
application object.  It takes the following parameters:description
+String dpy_str --- A character string naming the display the
application wishes to connect to.  If this value is
(String)NULL then the command line and user's environment is searched
for the display name.
+int *argc --- A pointer to an integer containing the number of
arguments in argv.
+char **argv --- An array of character strings representing the
command line arguments passed to the application.
+XrmOptionDescRec options[] --- An array of command line options.
These options are searched for in argv, any matching arguments are
removed.  Values associated with matched options are placed in the resource
database associated with this display connection.  They can be retrieved using
the XtGetApplicationResources() function.
+Cardinal num_options --- The number of options passed.
+String *app_defaults --- An array of character strings which
contain resource database entries in the form of "*Background: blue".
These are set as the application fallback resources, only used when an
application resource file cannot be found.
description

@(rule)@ 4in1mm

verbatim
void
XukcCreateUserInterface(toplevel)
    Widget toplevel;
verbatim
This routine creates the whole of the user interface as designed in Dirt.
It does this by examining the resource file created by Dirt and
creating objects that are described therein.  It also binds the created
objects to the Widget id variables (given in the
prefix_layout.h Dirt generated include file).  If the
resources file cannot be found and no suitable fallback resources were set
then this return causes the program to exit with an error message.
It takes a single parameter:description
+Widget toplevel --- The id of the application's shell object.
This is normally the Widget id returned by XukcDirtGO().
description

Creating deferred objects in an application

If an object was created or edited and has its Deferred creation 
mode set then neither it nor any descendants will be created when 
the XukcCreateUserInterface() call is made.  This facility can be 
used to implement the following techniques:itemize
+
Decrease application startup time by only creating objects on demand. 
+
Allow multiple objects to be created using the same layout and 
definition (multiple objects with the same object name) under program 
control.
+
Allow objects to be placed on different displays (or screens).

When XukcCreateUserInterface() is called it 
creates all the un-deferred objects, adds default callbacks and actions 
for all actions and callbacks registered in Dirt (these are 
overridden using calls to WcRegisterActions() and WcRegisterCallbacks()) and then places all the created objects' ids in 
their associated Widget variable.

To create deferred objects the WcCreateNamedChildren() call
can be used.  It takes two arguments:itemize
+
A Widget instance id which is the parent of the deferred children 
to be created.
+
A character string name of the deferred object that 
is to be created, all non deferred children of this object are also 
created. This name uses a wild-card naming scheme to allow specific 
parts of the object hierarchy to be created.

An example use of this command is:verbatim
    Widget deferred;

    WcCreateNamedChildren(a_parent, "aDeferredObjectName");
verbatim
To bind the created children to variable ids the Wc library function 
WcFullNameToWidget() should be used.  This function finds the 
named object in the object hierarchy and returns its associated widget 
id so that the object can be directly manipulated by the application.  
So for the above example the Widget variable deferred can be 
set using:verbatim
    deferred = WcFullNameToWidget(a_parent, ".aDeferredObjectName");
verbatim

Example Minimal Application

The convenience routines described in the previous section are used to 
create the user interface from the generated resources file.  What 
follows is a minimal program which simply creates the user interface and 
contains no application functionality.  It can be used as either a 
program to test user interface designs before the application 
functionality has been written or as a starting point to create the rest 
of the application:verbatim
    #include <X11/Intrinsic.h>
    #include <X11/StringDefs.h>

    extern Widget XukcDirtGO();
    extern void XukcCreateUserInterface();

    main(argc, argv)
    int argc;
    char *argv[];
    
        Widget tmp;

        tmp = XukcDirtGO(NULL, 	argc, argv, NULL, 0, NULL);

        /* register any callback or action routines with Wc via
         * WcRegisterCallback() and WcRegisterAction().
         */

        XukcCreateUserInterface(tmp);

        /* binding of the user interface to the application done here */

        XtRealizeWidget(tmp);
        XtAppMainLoop(XtWidgetToApplicationContext(tmp));
    
verbatim
This program is compiled along with the  prefix_create.c 
file created by Dirt:
@(hspace)@ 0.3incc -o app app.c prefix_create.c -lWc -lXaw -lXmu -lXt -lXext -lX11
The -lWc 
is the ``Widget Creation Library'' mentioned in Section @REF(ref{sec:saving})@  
and contains all the routines necessary to create the user interface 
from the generated resource file.  If object classes from other Widget 
sets are used in the interface their associated library should be also 
be given on the compile line; for example the UKC Widget Set is 
contained in the -lXukc library.

When app is executed it creates the user interface from the 
definition given in the resources file.  This file must therefore be 
placed in a directory known to the Xt Toolkit.  Setting the XENVIRONMENT environment variable to the absolute pathname of the 
directory containing the resource file can be used for testing purposes.  
The finished application should be placed in a system-wide directory 
known to the Xt Toolkit (e.g. /usr/lib/X11/app-defaults).

The above the absolute minimum code necessary to get a Dirt 
generated user interface up and running.  An application can be 
developed by binding the user interface object's callbacks and actions 
into the functions and procedures of the application.  This binding 
should normally be done just before the created interface is displayed 
(or realized) on the screen.

@(bibliography)@ database



APPENDIX
========


@(newpage)@ 
Dirt Command Line Options

The following command line options can be given to Dirt when it is
first started up.  They are in addition to the standard Xt Toolkit command
line options such as setting which display to connect to:description
+-appDisplay   display-name 
The display-name argument is taken as the display to build the user
interface on.  Use of this option allows Dirt to build user interfaces
that cannot be easily accommodated on the same display as Dirt
itself.

+-outputFile   file-prefix 
This option specifies the default prefix for all the C source code generated by
Dirt.  It would normally contain just the name of the application
(the files then being generated in the directory Dirt was started up
from).  The generated resources file is placed in the same directory as for the
generated source code.  This prefix can be later modified when the user
interface is being saved.

+-specFile   file-prefix 
This option specifies the default prefix for the Dirt specification file.
Dirt will try to load the specification from
 ``file-prefix.dirt_spec''.

+-files   file-prefix 
This option sets the filename prefix for both the specification and generated
code files.

+-pixels 
This flag causes all positions and sizes of created objects to be saved in
pixels (resolution dependent).

+-ruler 
This flag causes all positions and sizes of created objects to be saved in
units of measure form (resolution independent), either in millimetres or in
inches.

+-metric 
This flag sets the unit of measurement to be millimetres.

+-inches 
This flag sets the unit of measurement to be inches.

+-templates   directories 
This option tells Dirt which directories to look in for template files,
which are suffixed with  .dirt_template.
The directories are given as a single
argument with colons separating each directory name, e.g.
-templates ..:/s/rlh2/templates:/usr/local/lib/dirt
tells Dirt to look for templates in two absolutely named directories
and in the directory above the one Dirt was started up from.

New templates are saved in the first directory in the list or if this option
is missing, in the directory Dirt was started up from.

++snapToGrid 
Turn on snapping of an object's position and dimension when it is being
edited.  When turned on snapping allows the precise positioning and
sizing of objects to be made using the edited objects' selection grips.
An object is positioned and sized using these grips so that the associated
vertex is always on a grid point.  The spacing of this grid can be set
from the command line.

+-snapToGrid 
Turn off snapping of edited objects.

++showGrid 
Display the grid points in the parent object when editing a child object.

+-showGrid 
Do not display the grid points in the parent object when editing a child object.

+-grid   pixel-count 
Grid point spacing size.  This sets both the X and Y axis spacing.

+-xGrid   pixel-count 
Set the X axis grid point spacing size.

+-yGrid   pixel-count 
Set the Y axis grid point spacing size.

+-gridColour   colour 
Set the colour that grid points are displayed in.

+-gravityColour   colour 
Set the colour that gravity lines are drawn in.
description

@(newpage)@ 
Built-in Callback Routines

Dirt contains a set of callback routines that can be used within any
callback list resource.  These routines are part of
``Wc --- Widget Creation Library'' (-lWc) @CITE(cite{Wcl})@ .  They are 
analogous to similarly named functions in the Xt Toolkit 
Intrinsics @CITE(cite{XtIntrinsics})@ .

Arguments are normally given as widget (object) names, these names use a 
hierarchical naming scheme with wildcarding. Periods are used to 
separate parent and child objects, asterisks are used to match 
intermediate parents, for example: *fred.erik*john matches any 
objects called  john who have an ancestor called  erik whose 
parent is called  fred. Normally this naming scheme should only 
match one object.  A special widget name this can be used which 
means ``the object that invoked this routine''.

description
+WcCreateChildrenCB(parent, child [, child] ...) 
This callback creates the named children of the parent. The definition 
of the children are searched for in the resource database, this 
definition includes the class of the object, whether it is managed and
any children it may have.

+WcCreatePopupsCB(parent, child [, child] ...) 
This callback causes new pop-up (shell) widgets to be created.

+WcManageChildrenCB(parent, child [, child] ...) 
This callback places the named child objects into the managed set of the
named parent object.

+WcUnmanageChildrenCB(parent, child [, child] ...) 
This callback removes the named child objects from the managed set of the
named parent object.

+WcManageCB(widget [, widget] ...) 
This callback places each child widget into its parent's managed set
(causing the parent to re-layout its children).

+WcUnmanageCB(widget [, widget] ...) 
This callback removes each child widget from its parent's managed set
(causing the parent to re-layout its children).

+WcMapCB(shell widget) 
This callback ``maps'' the given Shell widget, displaying it on the screen. 

+WcUnmapCB(shell widget) 
This callback ``unmaps'' the given Shell widget, removing it from the screen. 

+WcDestroyCB(widget [, widget] ...) 
This callback destroys the named objects and removes them from the user
interface.

+WcSetSensitiveCB(widget [, widget] ...) 
This callback changes the ``sensitive'' resource of each named object to
TRUE.  This has the effect of allowing events to be sent to the object.

+WcSetInsensitiveCB(widget [, widget] ...) 
This callback changes the ``sensitive'' resource of each named object to
FALSE.  This has the effect of not allowing events to be sent to the object,
also some objects may change the way they look to reflect this change; i.e.
a push button object may gray itself out to show that it cannot be pressed.

+WcPopupCB(widget) 
This callback pops up (realizes) the named shell widget with a
non-exclusive (non-modal) grab on further events.

+WcPopupGrabCB(widget) 
This callback pops up the named shell widget with an exclusive (modal)
grab.  Any further events are only sent to this widget or any of its
children.  This routine can be used to create dialog boxes that must be
acknowledged by the user before continuing.

+WcPopdownCB(widget) 
This callback pops down (removes from the screen) the named shell widget.

+WcSetValueCB(<object.resource name>:<resource value>) 
This callback can be used to change values of resources in objects from
within the user interface.  The <object.resource name> specifies which
resource of an object to set to the new <resource value>.  When this
routine is executed the resource is updated and the object is informed (so
that it can re-display itself if necessary).  This routine can be used to
set virtually any resource in any object, which means that it can be used to
change the callbacks on a callback list resource, allowing some dynamic
programming of the interface from within Dirt.

+WcSetTypeValueCB(<object.resource name>: <resource
type>, <resource value>) 
This callback is an extension of the WcSetValueCB(). In addition to
changing the current value of a named resource, it also explicitly
converts the value represented as a string to the given resource
type, before updating the resource.

+WcLoadResourceFileCB(filename) 
This callback loads the resources found in the file: filename.  These
resources are merged into the application's current resource database and can
be used by the application or by the user interface when new objects are
created.

+WcSystemCB(``OS command line'') 
This callback takes the given parameter and passes it to the operating
system's system() procedure which executes the parameter as if it was
type at the command line.

+WcTraceCB(debugging annotation) 
This callback is for debugging only and allows the designer to watch what the
user interface is doing.  When this routine is executed any parameters passed
are printed on the standard output of the terminal that Dirt was
started from.

+WcExitCB(exitValue) 
This callback causes the application to quit, setting its exit status
to the passed value.  When prototyping from within Dirt this callback
displays a suitable message instead of quitting.

description

@(newpage)@ 
Built-in Action Routines

Dirt contains a set of actions routines that can be used within any
translation table.  These routines are part of
``Wc --- Widget Creation Library'' (-lWc) @CITE(cite{Wcl})@ . 
They are analogous to
similarly named functions in the Xt Toolkit Intrinsics @CITE(cite{XtIntrinsics})@ .
They perform the same function and take the same parameters as the Wc
callback routines described in Appendix @REF(ref{appendix:callbacks})@ . 

WcCreateChildrenACT(parent, child [, child] ...) 
WcManageChildrenACT(parent, child [, child] ...) 
WcUnmanageChildrenACT(parent, child [, child] ...) 
WcManageACT(widget [, widget] ...) 
WcUnmanageACT(widget [, widget] ...) 
WcMapCB(shell widget) 
WcUnmapCB(shell widget) 
WcDestroyACT(widget [, widget] ...) 
WcSetSensitiveACT(widget [, widget] ...) 
WcSetInsensitiveACT(widget [, widget] ...) 
WcPopupACT(widget) 
WcPopupGrabACT(widget) 
WcPopdownACT(widget) 
WcSetValueACT(``<object.resource name> : <resource value>'') 
WcSetTypeValueCB(<object.resource name>: <resource
type>, <resource value>) 
WcLoadResourceFileACT(filename) 
WcTraceACT(debugging annotation) 
WcSystemACT(OS command line) 
WcExitACT(exitValue) 

@(newpage)@ 
Object Classes Available in Dirt

The current object classes availble in Dirt fall in to two distinct
Widget Sets; the Athena Widget Set @CITE(cite{XawWidgets})@  and the UKC Widget
Set @CITE(cite{ukc-widgets})@ .  The Xt Intrinsics also define a small collection of
objects classes which are mainly used as superclasses to all other object
classes.

The Xt Toolkit Intrinsics define the following widget/object
classes: Core, Composite, Constraint, Shell,
OverrideShell, TransientShell, WMShell, VendorShell,
TopLevelShell, ApplicationShell.

The Athena Widget Set comes as the standard widget set for the Xt 
Toolkit as part of the MIT Distribution of the X Window System.

The UKC Widget Set is a smaller set of widgets that were mainly created 
forDirt but can be re-used across a wide selection of user 
interfaces. A lot of the objects are extensions of the Athena Widget
Set.



ENDNOTES
========

<1>: 
Design In Real Time.


<2>: 
The X Window System is a trademark of the Massachusetts Institute of
Technology.\\
\psfigfigure=figures/recycle.ps,height=0.2in --- Please recycle this
paper.


<3>: Or the object that contains most of the rectangle.

<4>: 
\tt xfontsel is a standard X client that comes with the MIT distribution of
X11 Release 4.


<5>: 
\tt xcoloredit is an X client created by the author which was made
available to the X community via the \em comp.sources.x USENET newsgroup.
It should be available on some anonymous ftp servers.


..EOF
